load socket
load regex

export IrcClient

/* Parts of this file are from the ircclient.fal from the simple IRC bot 
 * Used with kind permission form the author, Jeremy Cowgar(jeremy_c), perhaps this file will replace that one soon.
 * The message objects and message matcher were what was taken mainly.
 * Paul Davey, TechnoMancer
 */

// Copy begins here from ircclient.fal

class IrcMessage( raw, nRe, nClient )
    rawMessage = raw
    re = nRe
    client = nClient
   
    function name()
        return self.className()
    end
    
    function match(pattern)
        match = true
        if pattern.rawMessage
            match = (self.rawMessage == pattern.rawMessage) and match
        end
        if pattern.client
            match = (self.client == pattern.client) and match
        end
        return match
    end
    
    function toString()
        return @ "<IrcMessage> raw: \"$self.rawMessage\""
    end
end

/*
 * NOTICE AUTH :*** Checking ident
 * NOTICE falbot :*** Your host is simmons.freenode.net[simmons.freenode.net/6667], running version hyperion-1.0.2b
 */
 
class IrcNoticeMessage( raw, re, client ) from IrcMessage( raw, re, client )
    toWho   = nil
    message = nil
    
    init
        self.toWho   = self.rawMessage[ self.re.captured( 1 ) ]
        self.message = self.rawMessage[ self.re.captured( 2 ) ]
    end
    
    function match(pattern)
        match = self.IrcMessage.match(pattern) and true
        if pattern.toWho
            match = (self.toWho == pattern.toWho) and match
        end
        if pattern.message
            match = (self.message == pattern.message) and match
        end
        return match
    end
   
    function toString()
        return @ "<Notice Message> to: \"$self.toWho\" message: \"$self.message\""
    end
end

/*
 * PING :simmons.freenode.net
 */
 
class IrcPingMessage( raw, re, client ) from IrcMessage( raw, re, client )
    pingFrom = nil
    
    init
        self.pingFrom = strSplit( self.rawMessage[ self.re.captured( 1 ) ], "," )
    end
    
    function match(pattern)
        match = self.IrcMessage.match(pattern)
        if pattern.pingFrom
            match = (self.pingFrom == pattern.pingFrom) and match
        end
        return match
    end
    
    function toString()
        f = strMerge( self.pingFrom, " and " )
        return @"<Ping Message> from: $f"
    end
end

/*
 * :jeremy_c!n=jeremy_c@cpe-71-74-145-210.neo.res.rr.com JOIN :#falconpl
 */
 
class IrcJoinMessage( raw, re, client ) from IrcMessage( raw, re, client )
    user    = nil
    channel = nil
    
    init
        self.user    = self.rawMessage[ self.re.captured( 1 ) ]
        self.channel = self.rawMessage[ self.re.captured( 2 ) ]
    end
    
    function toString()
        return @"<Join Message> $self.user JOINED $self.channel"
    end
end

/*
 * :jeremy_c!n=jeremy@cpe-71-74-145-210.neo.res.rr.com PRIVMSG #johndoey :hello.
 */
 
class IrcPrivateMessage( raw, re, client ) from IrcMessage( raw, re, client )
    nick    = nil
    host    = nil
    channel = nil
    said    = nil
    
    init
        self.nick    = self.rawMessage[ self.re.captured( 1 ) ]
        self.host    = self.rawMessage[ self.re.captured( 2 ) ]
        self.channel = self.rawMessage[ self.re.captured( 3 ) ]
        self.said    = self.rawMessage[ self.re.captured( 4 ) ]
    end
   
    function toString()
        return @"<Private Message> $self.nick ($self.host) ON $self.channel SAID $self.said"
    end
end

/*
 * :jeremy_c!n=jeremy@cpe-71-74-145-210.neo.res.rr.com PART #johndoey :"Leaving"
 */
 
class IrcPartMessage( raw, re, client ) from IrcMessage( raw, re, client )
    nick    = nil
    host    = nil
    channel = nil
    message = nil

    init
        self.nick    = self.rawMessage[ self.re.captured( 1 ) ]
        self.host    = self.rawMessage[ self.re.captured( 2 ) ]
        self.channel = self.rawMessage[ self.re.captured( 3 ) ]
        self.message = self.rawMessage[ self.re.captured( 4 ) ]
    end

    function toString()
        return @ "<Part Message> $self.nick PARTED FROM $self.channel SAYING $self.message"
    end
end

//Copy ends here from ircclient.fal

class IrcNumericMessage(raw, re, client) from IrcMessage(raw, re, client)
    host = nil
    code = nil
    nick = nil
    channel = nil
    message = nil
    
    init
        host =      self.rawMessage[ self.re.captured( 1 ) ]
        code = int( self.rawMessage[ self.re.captured( 2 ) ] )
        nick =      self.rawMessage[ self.re.captured( 3 ) ]
        channel =   self.rawMessage[ self.re.captured( 4 ) ]
        message =   self.rawMessage[ self.re.captured( 5 ) ]
        if not channel
            channel = ""
        end
    end
    
    function match(pattern)
        match = self.IrcMessage.match(pattern)
        if pattern.host
            match = (self.host == pattern.host) and match
        end
        if pattern.code
            match = (self.code == pattern.code) and match
        end
        if pattern.nick
            match = (self.nick == pattern.nick) and match
        end
        if pattern.channel
            if self.channel
                match = (self.channel == pattern.channel) and match
            else
                match = false and match
            end
        end
        if pattern.message
            match = (self.message == pattern.message) and match
        end
        return match
    end
    
    function toString()
        if self.channel
            return @ "<Numeric Message> $self.host SENT $self.code TO $self.nick SENT $self.message"
        else
            return @ "<Numeric Message> $self.host SENT $self.code TO $self.nick IN $self.channel SENT $self.message"
        end
    end
end

/*
 * :Matt!bwctadmin@netadmin.spam.entirelyrandom.net MODE #chat + q Matt"
 */

class IrcModeMessage(raw, re, client) from IrcMessage(raw, re, client)
    nick = nil
    host = nil
    op = nil
    mode = nil
    channel = nil
    parameter = nil
    
    init
        nick = self.rawMessage[ self.re.captured( 1 ) ]
        host = self.rawMessage[ self.re.captured( 2 ) ]
        op   = self.rawMessage[ self.re.captured( 3 ) ]
        mode = self.rawMessage[ self.re.captured( 4 ) ]
        channel = self.rawMessage[ self.re.captured( 5 ) ]
        parameter = self.rawMessage[ self.re.captured( 6 ) ]
    end
end
class IrcClient(nHost, nPort, nNick, nName, nClientName, logTo) from TCPSocket
    host = nHost
    port = nPort
    nick = nNick
    name = nName
    clientName = nClientName
    buff = nil
    lines = List()
    logStream = logTo
    special = "" * 0x263a
    
    //inspired by the message matching in ircclient.fal
    messages = Table( .[ "regex"                                                                "message"           ],
                      .[ Regex( "NOTICE (\\w+) :(.*$)" )                                        IrcNoticeMessage    ],
                      .[ Regex( "PING :(.*)$" )                                                 IrcPingMessage      ],
                      .[ Regex( ":(.*)!(.*) JOIN :(.*)$" )                                      IrcJoinMessage      ],
                      .[ Regex( ":(.*)!(.*) PART (.*) :(.*)$" )                                 IrcPartMessage      ],
                      .[ Regex( ":(.*)!(.*) PRIVMSG ([^:]*) :(.*)$" )                           IrcPrivateMessage   ],
                      .[ Regex( ":([^ ]*) ([[:digit:]]{3}) ([^: ]*) (#[^: \a,])? :(.*)$" )      IrcNumericMessage   ],
                      .[ Regex( ":(.*)!(.*) MODE ([^ ]*) ([+-])([A-Za-z]+) ([^ ]*)?$" )        IrcModeMessage      ], 
                      .[ Regex( ":(.*)$" )                                                      IrcMessage          ]
              )
    //end
    
    init
    if self.logStream == nil
        self.generateLogFile()
    end
    end
    
    function generateLogFile()
        time = CurrentTime().toRFC2822().replace(" ", "_").replace(":", "_").replace("+", "p").replace("-", "m")
        self.logStream = OutputStream(@"Log-$(time)-$(self.clientName).log")
    end
    
    function connect()
        self.TCPSocket.setTimeout(0)
        self.log( "Connecting")
        self.TCPSocket.connect(self.host, toString(self.port))
        while self.TCPSocket.isConnected() == false
            sleep(0.1)
        end
        self.log( "done.")
        self.log( "Connected, Logging in")
        self.logStream.flush()
        self.TCPSocket.setTimeout(0.1)
        self.login()
        launch self.connectionHandler()
        subscribe("IrcPingMessage", self.pong)
        return true
    end
    
    function send(msg)
        return ((self.TCPSocket.send(msg + "\n\r")) > 0)
    end
    
    function read()
        
        self.buff = self.TCPSocket.recv( 4096)
        if len(self.buff) == 0
            return false
        else
            self.buff.replace("\n\r", "\n")
            self.buff.replace("\r", "\n")
            for line in self.buff.split("\n")
                self.lines.push(line.backTrim())
            end
            return true
        end
    end
    
    function readline()
        if not self.lines.empty()
            return self.lines.popFront()
        else
            self.read()
            return false
        end
    end
    
    function connectionHandler()
        while true
            line = self.readline()
            if line
                for p in self.messages
                    if p.regex.match( line )
                        message = p.message( line, p.regex, self )
                        launch broadcast(message.name(), message)
                        break
                    end
                end
            end
            sleep(0.01)
        end
    end
    
    // Methods for various IRC commands.
    function sendTo( name, msg)
        return ((self.send(@"PRIVMSG $name :$msg")) > 0)
    end
    
    function login()
        self.send(@"NICK :$self.nick")
        self.send(@"USER $self.nick 0 * :$self.name")
    end
    
    function pong(message)
        > "Ponging: " + message.pingFrom[ 0 ]
        message.client.send( "PONG " + message.pingFrom[ 0 ] )
    end
    
    function quit(reason)
        if not reason
            reason = ""
        end
        self.send( "QUIT " + reason)
    end
    
    function join(channel)
        self.send(@"JOIN $channel")
    end
    
    function kick(channel, nick, reason)
        if not reason
            reason = ""
        end
        self.send(@"KICK $channel $nick :$reason")
    end
    
    function ban(channel, nick, reason)
        reason = reason ? reason : ""
        self.send(@"KICK $channel $nick :$reason")
    end
    
    function part(channel)
        self.send(@"PART $channel")
    end
    
    function mode(channelOrNick, mode, limit, user, banMask)
        limit = limit ? limit : ""
        user = user ? user : ""
        banMask = banMask ? banMask : ""
        self.send(@"MODE $channelOrNick $mode $limit $user $banMask")
    end
    
    function log(text)
        if self.logStream
            self.logStream.writeText(CurrentTime().toRFC2822() + " " + self.clientName + ": " + text + "\n")
            self.logStream.flush()
        end
    end
        
end